<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta content="text/html; charset=windows-1252"
      http-equiv="content-type">
    <title>RELEASE_NOTES</title>
    <style>
<!--
pre          {  }
-->
  </style>
  </head>
  <body>
    The complete documentation on DAL package is available on <a
      href="https://twiki.cern.ch/twiki/bin/view/Atlas/DaqHltDal">the
      DAL TWiki page</a>. Below there is a summary of important changes
    since previous public release.<br>
    <h3 class="prioreclosed">Segments</h3>
    <ul>
      <li>The concept of the template segments has been introduced.</li>
      <li>The computers for template applications and applications with
        empty runs on relationship are calculated using new hosts
        relationship.</li>
      <li>The programming access to segments are their properties should
        be performed using new API.<br>
      </li>
    </ul>
    <h4>Template Segments<br>
    </h4>
    <p>Like template applications, multiple segments can be described by
      single database object of the <i>TemplateSegment</i> class. Such
      segments are mainly introduced by needs of the trigger
      configuration description, where the only difference between
      configurations for different trigger racks is defined by trigger
      processing unit objects (i.e. TPU computers). The template
      segments are generated on-fly by DAL algorithms. The number of
      template segments is defined by number of rack objects included
      via <i>"</i><i>Racks</i><i>"</i> relationship. A name of such
      segment is generated as <em>"segment-db-id:rack-db-id"</em> and
      the hosts of such segment are defined by <i>"</i><i>Nodes</i><i>"</i>
      relationship of the rack object. A template segment may have
      template applications only. A template segment may not have nested
      segments or explicitly defined hosts.
      Individual template segment can be disabled, if corresponding rack
      object is put into partition's <i>"Disabled</i><i>"</i>
      relationship. </p>
    <h4>Hosts<br>
    </h4>
    <p>A segment object defines computers, where applications without
      explicitly defined hosts are running. Such computers are defined
      via <i>"Hosts"</i> relationship for a normal segment and via <i>"Nodes"</i>
      relationship of corresponding rack object for a template segment.
      This relationship points to the objects of the abstract <em>ComputerBase</em>
      class, which are instantiated either as real computers (objects of
      the <em>Computer</em> class) of their logical unions (objects of
      the <em>ComputerSet</em> class). The <i>DefaultHost</i> and the
      <i>BackupHost</i> relationships have been removed: the default
      host is the first host in state <i>"On"</i> of the <i>Hosts</i>
      relationship and the backup hosts are either explicitly defined
      for infrastructure applications, or first good (i.e. passed a
      test) host of the <i>Hosts</i> relationship.<br>
    </p>
    <h4>API<br>
    </h4>
    <p>To access properties of a segment or to iterate a tree of nested
      segments one should use <i>SegConfig</i> class defined in both <a
href="http://atlas-tdaq-sw.web.cern.ch/atlas-tdaq-sw/doxygen/tdaq/nightly/html/d1/de1/classdaq_1_1core_1_1SegConfig.html"
        target="_top">C++</a> and <a
href="http://atlas-tdaq-sw.web.cern.ch/atlas-tdaq-sw/javadoc/tdaq/nightly/dal/SegConfig.html"
        target="_top">Java</a> libraries. It takes into account normal
      and template segments of the partition as well as the partition's
      online segment. To get <i>SegConfig</i> object use <i>get_segment()</i>
      algorithms of the Partition class (see <a
href="http://atlas-tdaq-sw.web.cern.ch/atlas-tdaq-sw/doxygen/tdaq/nightly/html/d0/d05/classdaq_1_1core_1_1Partition.html#a9c408504ccae4aa347b4cfe9cbd86c2e"
        target="_top">C++</a> and <a
href="http://atlas-tdaq-sw.web.cern.ch/atlas-tdaq-sw/javadoc/tdaq/nightly/dal/Partition.html#get_segment%28java.lang.String,%20boolean,%20int%29"
        target="_top">Java</a> links). Above algorithm allows to limit
      depth of nested segments description (e.g. for efficiency reasons)
      using optional <em>depth</em> parameter. If the <i>depth</i>
      parameter is set to 0, then get description of this segment only
      (no description of nested segments is provided even if there are
      such segments in database). The Run Control may set depth
      parameter equal to 1 to get information about controller and
      infrastructure of nested segments to set them up. If depth
      parameter is used with default value, the algorithm returns
      description of all nested segments.
    </p>
    <h3 class="prioreclosed">Applications</h3>
    <ul>
      <li><span class="st">Sort out ambiguities in attribute names of
          the base application class.</span></li>
      <li><span class="st">Make the application class abstract and
          introduce new class with well defined lifetime policy.</span></li>
      <li><span class="st">Make selection of hosts for template
          applications more flexible.</span></li>
      <li><span class="st">Reduce number of relationships between
          applications and segment.</span></li>
    </ul>
    <h4><span class="st">Attributes</span><span class="st"> Changes</span></h4>
    <p>Rename ambiguous attributes as shown below:<br>
    </p>
    <ul>
      <li><i>IfDies</i> becomes <i>IfExitsUnexpectedly </i><br>
      </li>
      <li><i>IfFailed</i> becomes <i>IfFailsToStart</i></li>
    </ul>
    Remove <i>StartAt</i> and <i>StopAt</i> attributes from the base
    application class, since they have no sense for run control and
    infrastructure applications. In addition there were unsupported
    combinations of their values.<i><br>
    </i>
    <h4>Classes Changes</h4>
    Introduce new custom lifetime classes, which are replacing
    application and template application classes. The lifetime of such
    applications is defined by the <em>Lifetime</em> attribute:
    <ul>
      <li> <i>"Boot_Shutdown"</i> - start at <em>boot</em> and stop
        before <em>shutdown</em>
      </li>
      <li> <i>"SOR_EOR"</i> - start at <em>start of run</em> and stop
        before <em>end of run</em>
      </li>
      <li> <i>"EOR_SOR"</i> - start at <em>end of run</em> and stop
        before <em>start of run</em> or before <em>shutdown</em>
      </li>
      <li> <i>"UserDefined_Shutdown"</i> - start at any moment and stop
        before <em>shutdown</em>
      </li>
    </ul>
    <p>
      The attribute <em>AllowSpontaneousExit</em> defines reaction on
      exit before expected moment. If the spontaneous exit is not
      allowed or the application exits with non-zero status, then the
      system will behave as specified by the <em>IfExitsUnexpectedly</em>
      attribute of the <em>BaseApplication</em> class.
    </p>
    The <i>Application</i> and <i>TemplateApplication</i> classes
    become abstract, since they do not define any clear lifetime policy.
    To port old databases to new schema the classes of existing objects
    in OKS files have to be renamed to appropriate <i>CustomLifetime</i>
    classes in any text editor and correct <em>Lifetime</em> and <em>IfExitsUnexpectedly
    </em>attribute values have to be set as required afterwards.<br>
    <h4>Where to Run Template Applications</h4>
    The set of computers for template applications is defined by the <i>Hosts</i>
    relationship for a normal segment and by the <i>Nodes</i>
    relationship of related rack for template segments. It is possible
    to select a subset of such hosts per template applications as
    defined by the value of new <em>RunsOn</em> attribute, that can be:<br>
    <ul>
      <li><em>all</em>,</li>
      <li><em>first</em>, or</li>
      <li><em>all-but-first</em></li>
    </ul>
    <h4>Link Application with Segment</h4>
    <p>
      Applications can be linked with a segment by one of the following
      ways: </p>
    <ul>
      <li> via <em>IsControlledBy</em> relationship (segment's
        controller);
      </li>
      <li> via <em>Infrastructure</em> relationship (infrastructure
        providing segment's services);
      </li>
      <li> via <em>Applications</em> relationship (typical user
        application);
      </li>
      <li> via <em>Resources</em> relationship (when application is a
        resource, it can de disabled).</li>
    </ul>
    Thus there is no any special relationship for template application,
    that depending on class can be put in any above relationship.<br>
    <h3>Message Passing Applications</h3>
    The calculation of message passing node ID and support of message
    passing application specific classes and algorithms have been
    completely removed.<br>
    <br>
    <h4> </h4>
  </body>
</html>
